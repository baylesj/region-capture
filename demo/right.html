<html>
  <head>
    <link rel="icon" href="data:;base64,=" />
  </head>
  <body>
    <h1>Video Conferencing App</h1>
    <br /><br /><br />
    <video id="video" autoplay playsinline style="border: none"></video>
    <br /><br /><br />
    <button id="button0" onclick="OnSourceSelected(0);" disabled>Source #1</button>
    <button id="button1" onclick="OnSourceSelected(1);" disabled>Source #2</button>
    <button id="uncropped" onclick="OnUncroppedSelected();" disabled>Uncropped</button>
    <br />
    <p id="errorMessage" style="color: red"></p>
    <br />
    <p>
      If you can observe a shimmering effect, that's an unrelated issue. Get around it by popping
      into picture-in-picture mode.
    </p>
    <button id="pipButton" onclick="OnPipClicked();" disabled>PiP</button>
    <script>
      const video = document.getElementById("video");
      const pipButton = document.getElementById("pipButton");
      const errorMessage = document.getElementById("errorMessage");
      let track;
      let cropIDs = [];
      let pip;

      const broadcastChannel = new BroadcastChannel("region-capture-demo");
      broadcastChannel.onmessage = onBroadcastChannelMessage;

      async function MaybeStartCapturing() {
        errorMessage.innerHTML = "";

        if (track && track.readyState == "live") {
          return true;
        }

        let stream;
        try {
          stream = await navigator.mediaDevices.getDisplayMedia({
            preferCurrentTab: true,
          });
        } catch (e) {
          return false;
        }

        [track] = stream.getVideoTracks();
        if (!track.label.startsWith("current-web-contents-media-stream://")) {
          track.stop();
          track = undefined;
          errorMessage.innerHTML =
            "This demo only works when capturing the current tab.<br />" +
            "Cropping another tab is a future extension of the API.<br />" +
            "Cropping anything but a tab is not currently planned.";
          return false;
        }

        track.onended = () => {
          pipButton.disabled = true;
          video.srcObject = undefined;
          if (document.pictureInPictureElement) {
            document.exitPictureInPicture();
          }
        };

        video.srcObject = stream;
        pipButton.disabled = false;
        return true;
      }

      async function OnSourceSelected(source) {
        video.style = "border: none;";
        if (await MaybeStartCapturing()) {
          video.pause();
          await track.cropTo(cropIDs[source]);
          video.play();
        }
      }

      async function OnUncroppedSelected() {
        if (await MaybeStartCapturing()) {
          // TODO: This should not be hard-coded, just capped to the size of the div.
          video.style = "border: none; width: 500px; height: 500px;";
          video.pause();
          track.cropTo("");
          video.play();
        }
      }

      function OnPipClicked() {
        video.requestPictureInPicture();
      }

      function onBroadcastChannelMessage(serializedMessage) {
        try {
          const msg = JSON.parse(serializedMessage.data);
          if (msg.init) {
            init();
          } else if (msg.cropID) {
            cropIDs.push(msg.cropID);
          }
        } catch (error) {
          console.error(`${error}`);
        }
      }

      function init() {
        ["button0", "button1", "uncropped"].forEach((buttonId) => {
          document.getElementById(buttonId).disabled = false;
        });
      }
    </script>
  </body>
</html>
